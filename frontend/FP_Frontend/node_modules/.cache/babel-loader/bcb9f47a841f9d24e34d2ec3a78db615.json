{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nvar _marked = _regeneratorRuntime.mark(meshPrimitiveIterator);\n\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../gltf-constants';\nimport { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';\nimport { parse } from '@loaders.gl/core';\n\nvar KHR_draco_mesh_compression = function () {\n  function KHR_draco_mesh_compression() {\n    _classCallCheck(this, KHR_draco_mesh_compression);\n  }\n\n  _createClass(KHR_draco_mesh_compression, null, [{\n    key: \"decode\",\n    value: function () {\n      var _decode = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(gltfData) {\n        var options,\n            scenegraph,\n            promises,\n            _iteratorNormalCompletion,\n            _didIteratorError,\n            _iteratorError,\n            _iterator,\n            _step,\n            primitive,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n                if (options.decompress) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                scenegraph = new GLTFScenegraph(gltfData);\n                promises = [];\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context.prev = 8;\n\n                for (_iterator = meshPrimitiveIterator(scenegraph)[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  primitive = _step.value;\n\n                  if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n                    promises.push(decompressPrimitive(primitive, scenegraph, options));\n                  }\n                }\n\n                _context.next = 16;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](8);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 16:\n                _context.prev = 16;\n                _context.prev = 17;\n\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                  _iterator[\"return\"]();\n                }\n\n              case 19:\n                _context.prev = 19;\n\n                if (!_didIteratorError) {\n                  _context.next = 22;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 22:\n                return _context.finish(19);\n\n              case 23:\n                return _context.finish(16);\n\n              case 24:\n                _context.next = 26;\n                return Promise.all(promises);\n\n              case 26:\n                scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n\n              case 27:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[8, 12, 16, 24], [17,, 19, 23]]);\n      }));\n\n      function decode(_x) {\n        return _decode.apply(this, arguments);\n      }\n\n      return decode;\n    }()\n  }, {\n    key: \"decodeSync\",\n    value: function decodeSync(gltfData, options) {\n      if (!options.decompress) {\n        return;\n      }\n\n      var scenegraph = new GLTFScenegraph(gltfData);\n\n      if (scenegraph.getRequiredExtension(KHR_DRACO_MESH_COMPRESSION)) {\n        throw new Error('Cannot synchronously decode Draco');\n      }\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(gltfData) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var scenegraph = new GLTFScenegraph(gltfData);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = (scenegraph.json.meshes || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var mesh = _step2.value;\n          compressMesh(mesh, options);\n          scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return KHR_DRACO_MESH_COMPRESSION;\n    }\n  }]);\n\n  return KHR_draco_mesh_compression;\n}();\n\nexport { KHR_draco_mesh_compression as default };\n\nfunction decompressPrimitive(_x2, _x3, _x4) {\n  return _decompressPrimitive.apply(this, arguments);\n}\n\nfunction _decompressPrimitive() {\n  _decompressPrimitive = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(primitive, scenegraph, options) {\n    var compressedPrimitive, buffer, subArray, bufferCopy, decodedData;\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            compressedPrimitive = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n            buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);\n            subArray = new Uint8Array(buffer.buffer).subarray(buffer.byteOffset);\n            bufferCopy = new Uint8Array(subArray);\n            _context3.next = 6;\n            return parse(bufferCopy);\n\n          case 6:\n            decodedData = _context3.sent;\n            primitive.attributes = getGLTFAccessors(decodedData.attributes);\n\n            if (decodedData.indices) {\n              primitive.indices = getGLTFAccessor(decodedData.indices);\n            }\n\n            checkPrimitive(primitive);\n\n          case 10:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _decompressPrimitive.apply(this, arguments);\n}\n\nfunction compressMesh(attributes, indices) {\n  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (!options.DracoWriter || !options.DracoLoader) {\n    throw new Error('DracoWriter/DracoLoader not available');\n  }\n\n  var compressedData = options.DracoWriter.encodeSync({\n    attributes: attributes\n  });\n  var decodedData = options.DracoLoader.parseSync({\n    attributes: attributes\n  });\n\n  var fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  var bufferViewIndex = options.addBufferView(compressedData);\n  var glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      mode: mode,\n      extensions: _defineProperty({}, KHR_DRACO_MESH_COMPRESSION, {\n        bufferView: bufferViewIndex,\n        attributes: fauxAccessors\n      })\n    }]\n  };\n  return glTFMesh;\n}\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('Empty glTF primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction meshPrimitiveIterator(scenegraph) {\n  var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, mesh, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, primitive;\n\n  return _regeneratorRuntime.wrap(function meshPrimitiveIterator$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _iteratorNormalCompletion3 = true;\n          _didIteratorError3 = false;\n          _iteratorError3 = undefined;\n          _context2.prev = 3;\n          _iterator3 = (scenegraph.json.meshes || [])[Symbol.iterator]();\n\n        case 5:\n          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n            _context2.next = 36;\n            break;\n          }\n\n          mesh = _step3.value;\n          _iteratorNormalCompletion4 = true;\n          _didIteratorError4 = false;\n          _iteratorError4 = undefined;\n          _context2.prev = 10;\n          _iterator4 = mesh.primitives[Symbol.iterator]();\n\n        case 12:\n          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n            _context2.next = 19;\n            break;\n          }\n\n          primitive = _step4.value;\n          _context2.next = 16;\n          return primitive;\n\n        case 16:\n          _iteratorNormalCompletion4 = true;\n          _context2.next = 12;\n          break;\n\n        case 19:\n          _context2.next = 25;\n          break;\n\n        case 21:\n          _context2.prev = 21;\n          _context2.t0 = _context2[\"catch\"](10);\n          _didIteratorError4 = true;\n          _iteratorError4 = _context2.t0;\n\n        case 25:\n          _context2.prev = 25;\n          _context2.prev = 26;\n\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n\n        case 28:\n          _context2.prev = 28;\n\n          if (!_didIteratorError4) {\n            _context2.next = 31;\n            break;\n          }\n\n          throw _iteratorError4;\n\n        case 31:\n          return _context2.finish(28);\n\n        case 32:\n          return _context2.finish(25);\n\n        case 33:\n          _iteratorNormalCompletion3 = true;\n          _context2.next = 5;\n          break;\n\n        case 36:\n          _context2.next = 42;\n          break;\n\n        case 38:\n          _context2.prev = 38;\n          _context2.t1 = _context2[\"catch\"](3);\n          _didIteratorError3 = true;\n          _iteratorError3 = _context2.t1;\n\n        case 42:\n          _context2.prev = 42;\n          _context2.prev = 43;\n\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n\n        case 45:\n          _context2.prev = 45;\n\n          if (!_didIteratorError3) {\n            _context2.next = 48;\n            break;\n          }\n\n          throw _iteratorError3;\n\n        case 48:\n          return _context2.finish(45);\n\n        case 49:\n          return _context2.finish(42);\n\n        case 50:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked, null, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);\n}","map":null,"metadata":{},"sourceType":"module"}
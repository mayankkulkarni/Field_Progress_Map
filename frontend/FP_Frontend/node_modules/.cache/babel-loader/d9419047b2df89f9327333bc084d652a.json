{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport PathTesselator from './path-tesselator';\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  widthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  rounded: false,\n  miterLimit: {\n    type: 'number',\n    min: 0,\n    value: 4\n  },\n  dashJustified: false,\n  billboard: false,\n  getPath: {\n    type: 'accessor',\n    value: function value(object) {\n      return object.path;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\nvar ATTRIBUTE_TRANSITION = {\n  enter: function enter(value, chunk) {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nvar PathLayer = function (_Layer) {\n  _inherits(PathLayer, _Layer);\n\n  function PathLayer() {\n    _classCallCheck(this, PathLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathLayer).apply(this, arguments));\n  }\n\n  _createClass(PathLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(PathLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: ['project32', 'picking']\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var noAlloc = true;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        startPositions: {\n          size: 3,\n          offset: 12,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculateStartPositions,\n          noAlloc: noAlloc,\n          shaderAttributes: {\n            instanceLeftPositions: {\n              offset: 0\n            },\n            instanceStartPositions: {\n              offset: 12\n            }\n          }\n        },\n        endPositions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculateEndPositions,\n          noAlloc: noAlloc,\n          shaderAttributes: {\n            instanceEndPositions: {\n              offset: 0\n            },\n            instanceRightPositions: {\n              offset: 12\n            }\n          }\n        },\n        instanceTypes: {\n          size: 1,\n          type: 5121,\n          update: this.calculateSegmentTypes,\n          noAlloc: noAlloc\n        },\n        instanceStrokeWidths: {\n          size: 1,\n          accessor: 'getWidth',\n          transition: ATTRIBUTE_TRANSITION,\n          defaultValue: 1\n        },\n        instanceDashArrays: {\n          size: 2,\n          accessor: 'getDashArray'\n        },\n        instanceColors: {\n          size: this.props.colorFormat.length,\n          type: 5121,\n          normalized: true,\n          accessor: 'getColor',\n          transition: ATTRIBUTE_TRANSITION,\n          defaultValue: DEFAULT_COLOR\n        },\n        instancePickingColors: {\n          size: 3,\n          type: 5121,\n          accessor: function accessor(object, _ref) {\n            var index = _ref.index,\n                value = _ref.target;\n            return _this.encodePickingColor(index, value);\n          }\n        }\n      });\n      this.setState({\n        pathTesselator: new PathTesselator({\n          fp64: this.use64bitPositions()\n        })\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n\n      _get(_getPrototypeOf(PathLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      var attributeManager = this.getAttributeManager();\n      var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n      if (geometryChanged) {\n        var pathTesselator = this.state.pathTesselator;\n        pathTesselator.updateGeometry({\n          data: props.data,\n          getGeometry: props.getPath,\n          positionFormat: props.positionFormat,\n          dataChanged: changeFlags.dataChanged\n        });\n        this.setState({\n          numInstances: pathTesselator.instanceCount,\n          bufferLayout: pathTesselator.bufferLayout\n        });\n\n        if (!changeFlags.dataChanged) {\n          attributeManager.invalidateAll();\n        }\n      }\n\n      if (changeFlags.extensionsChanged) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model[\"delete\"]();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var viewport = this.context.viewport;\n      var _this$props = this.props,\n          rounded = _this$props.rounded,\n          billboard = _this$props.billboard,\n          miterLimit = _this$props.miterLimit,\n          widthUnits = _this$props.widthUnits,\n          widthScale = _this$props.widthScale,\n          widthMinPixels = _this$props.widthMinPixels,\n          widthMaxPixels = _this$props.widthMaxPixels,\n          dashJustified = _this$props.dashJustified;\n      var widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;\n      this.state.model.setUniforms(Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        billboard: billboard,\n        alignMode: Number(dashJustified),\n        widthScale: widthScale * widthMultiplier,\n        miterLimit: miterLimit,\n        widthMinPixels: widthMinPixels,\n        widthMaxPixels: widthMaxPixels\n      })).draw();\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      var SEGMENT_INDICES = [0, 2, 1, 1, 2, 4, 1, 4, 3, 3, 4, 5];\n      var SEGMENT_POSITIONS = [0, 0, 1, 0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0, 1, 0, 1];\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 4,\n          attributes: {\n            indices: new Uint16Array(SEGMENT_INDICES),\n            positions: new Float32Array(SEGMENT_POSITIONS)\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"calculateStartPositions\",\n    value: function calculateStartPositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.bufferLayout = pathTesselator.bufferLayout;\n      attribute.value = pathTesselator.get('startPositions');\n    }\n  }, {\n    key: \"calculateEndPositions\",\n    value: function calculateEndPositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.bufferLayout = pathTesselator.bufferLayout;\n      attribute.value = pathTesselator.get('endPositions');\n    }\n  }, {\n    key: \"calculateSegmentTypes\",\n    value: function calculateSegmentTypes(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.bufferLayout = pathTesselator.bufferLayout;\n      attribute.value = pathTesselator.get('segmentTypes');\n    }\n  }]);\n\n  return PathLayer;\n}(Layer);\n\nexport { PathLayer as default };\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport log from '../utils/log';\nimport DrawLayersPass from '../passes/draw-layers-pass';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport PostProcessEffect from '../effects/post-process-effect';\nimport { Framebuffer } from '@luma.gl/core';\nvar LOG_PRIORITY_DRAW = 2;\n\nvar DeckRenderer = function () {\n  function DeckRenderer(gl) {\n    _classCallCheck(this, DeckRenderer);\n\n    this.gl = gl;\n    this.layerFilter = null;\n    this.drawPickingColors = false;\n    this.drawLayersPass = new DrawLayersPass(gl);\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.renderCount = 0;\n    this._needsRedraw = 'Initial render';\n    this.screenBuffer = null;\n    this.offscreenBuffer = null;\n    this.lastPostProcessEffect = null;\n  }\n\n  _createClass(DeckRenderer, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('layerFilter' in props) {\n        if (this.layerFilter !== props.layerFilter) {\n          this.layerFilter = props.layerFilter;\n          this._needsRedraw = 'layerFilter changed';\n        }\n      }\n\n      if ('drawPickingColors' in props) {\n        if (this.drawPickingColors !== props.drawPickingColors) {\n          this.drawPickingColors = props.drawPickingColors;\n          this._needsRedraw = 'drawPickingColors changed';\n        }\n      }\n\n      var layerFilter = this.layerFilter;\n      this.drawLayersPass.setProps({\n        layerFilter: layerFilter\n      });\n      this.pickLayersPass.setProps({\n        layerFilter: layerFilter\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers(_ref) {\n      var _this = this;\n\n      var layers = _ref.layers,\n          viewports = _ref.viewports,\n          activateViewport = _ref.activateViewport,\n          views = _ref.views,\n          _ref$redrawReason = _ref.redrawReason,\n          redrawReason = _ref$redrawReason === void 0 ? 'unknown reason' : _ref$redrawReason,\n          _ref$clearCanvas = _ref.clearCanvas,\n          clearCanvas = _ref$clearCanvas === void 0 ? true : _ref$clearCanvas,\n          _ref$effects = _ref.effects,\n          effects = _ref$effects === void 0 ? [] : _ref$effects,\n          pass = _ref.pass,\n          stats = _ref.stats;\n      var layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;\n      var effectProps = this.prepareEffects({\n        layers: layers,\n        viewports: viewports,\n        onViewportActive: activateViewport,\n        views: views,\n        effects: effects\n      });\n      var outputBuffer = this.lastPostProcessEffect ? this.screenBuffer : Framebuffer.getDefaultFramebuffer(this.gl);\n      var renderStats = layerPass.render({\n        layers: layers,\n        viewports: viewports,\n        views: views,\n        onViewportActive: activateViewport,\n        redrawReason: redrawReason,\n        clearCanvas: clearCanvas,\n        effects: effects,\n        effectProps: effectProps,\n        outputBuffer: outputBuffer\n      });\n      this.postRender(effects);\n      this.renderCount++;\n\n      if (log.priority >= LOG_PRIORITY_DRAW) {\n        renderStats.forEach(function (status) {\n          _this.logRenderStats({\n            status: status,\n            pass: pass,\n            redrawReason: redrawReason,\n            stats: stats,\n            renderStats: renderStats\n          });\n        });\n      }\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearRedrawFlags: false\n      };\n      var redraw = this._needsRedraw;\n\n      if (opts.clearRedrawFlags) {\n        this._needsRedraw = false;\n      }\n\n      return redraw;\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      if (this.screenBuffer) {\n        this.screenBuffer[\"delete\"]();\n        this.screenBuffer = null;\n      }\n\n      if (this.offscreenBuffer) {\n        this.offscreenBuffer[\"delete\"]();\n        this.offscreenBuffer = null;\n      }\n    }\n  }, {\n    key: \"prepareEffects\",\n    value: function prepareEffects(params) {\n      var effects = params.effects;\n      var effectProps = {};\n      this.lastPostProcessEffect = null;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var effect = _step.value;\n          Object.assign(effectProps, effect.prepare(this.gl, params));\n\n          if (effect instanceof PostProcessEffect) {\n            this.lastPostProcessEffect = effect;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (this.lastPostProcessEffect) {\n        this.prepareRenderBuffers();\n      }\n\n      return effectProps;\n    }\n  }, {\n    key: \"prepareRenderBuffers\",\n    value: function prepareRenderBuffers() {\n      if (!this.screenBuffer) {\n        this.screenBuffer = new Framebuffer(this.gl);\n      }\n\n      this.screenBuffer.resize();\n\n      if (!this.offscreenBuffer) {\n        this.offscreenBuffer = new Framebuffer(this.gl);\n      }\n\n      this.offscreenBuffer.resize();\n    }\n  }, {\n    key: \"postRender\",\n    value: function postRender(effects) {\n      var params = {\n        inputBuffer: this.screenBuffer,\n        outputBuffer: this.offscreenBuffer,\n        target: null\n      };\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var effect = _step2.value;\n\n          if (effect instanceof PostProcessEffect) {\n            if (effect === this.lastPostProcessEffect) {\n              Object.assign(params, {\n                target: Framebuffer.getDefaultFramebuffer(this.gl)\n              });\n              params = effect.render(params);\n              break;\n            }\n\n            params = effect.render(params);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"logRenderStats\",\n    value: function logRenderStats(_ref2) {\n      var renderStats = _ref2.renderStats,\n          pass = _ref2.pass,\n          redrawReason = _ref2.redrawReason,\n          stats = _ref2.stats;\n      var totalCount = renderStats.totalCount,\n          visibleCount = renderStats.visibleCount,\n          compositeCount = renderStats.compositeCount,\n          pickableCount = renderStats.pickableCount;\n      var primitiveCount = totalCount - compositeCount;\n      var hiddenCount = primitiveCount - visibleCount;\n      var message = '';\n      message += \"RENDER #\".concat(this.renderCount, \" \").concat(visibleCount, \" (of \").concat(totalCount, \" layers) to \").concat(pass, \" because \").concat(redrawReason, \" \");\n\n      if (log.priority > LOG_PRIORITY_DRAW) {\n        message += \"(\".concat(hiddenCount, \" hidden, \").concat(compositeCount, \" composite \").concat(pickableCount, \" pickable)\");\n      }\n\n      log.log(LOG_PRIORITY_DRAW, message)();\n\n      if (stats) {\n        stats.get('Redraw Layers').add(visibleCount);\n      }\n    }\n  }]);\n\n  return DeckRenderer;\n}();\n\nexport { DeckRenderer as default };","map":null,"metadata":{},"sourceType":"module"}
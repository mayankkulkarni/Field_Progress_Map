{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { assembleShaders } from '@luma.gl/shadertools';\nimport { Program } from '@luma.gl/webgl';\n\nvar ProgramManager = function () {\n  _createClass(ProgramManager, null, [{\n    key: \"getDefaultProgramManager\",\n    value: function getDefaultProgramManager(gl) {\n      gl.luma = gl.luma || {};\n      gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n      return gl.luma.defaultProgramManager;\n    }\n  }]);\n\n  function ProgramManager(gl) {\n    _classCallCheck(this, ProgramManager);\n\n    this.gl = gl;\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {};\n    this._moduleInjections = {\n      vs: {},\n      fs: {}\n    };\n    this._hookFunctions = {\n      vs: {},\n      fs: {}\n    };\n    this._defaultModules = [];\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0;\n    this._useCounts = {};\n  }\n\n  _createClass(ProgramManager, [{\n    key: \"addDefaultModule\",\n    value: function addDefaultModule(module) {\n      if (!this._defaultModules.find(function (m) {\n        return m.name === module.name;\n      })) {\n        this._defaultModules.push(module);\n      }\n\n      this.stateHash++;\n    }\n  }, {\n    key: \"removeDefaultModule\",\n    value: function removeDefaultModule(module) {\n      var moduleName = typeof module === 'string' ? module : module.name;\n      this._defaultModules = this._defaultModules.filter(function (m) {\n        return m.name !== moduleName;\n      });\n      this.stateHash++;\n    }\n  }, {\n    key: \"addModuleInjection\",\n    value: function addModuleInjection(module, opts) {\n      var moduleName = typeof module === 'string' ? module : module.name;\n      var hook = opts.hook,\n          injection = opts.injection,\n          _opts$order = opts.order,\n          order = _opts$order === void 0 ? 0 : _opts$order;\n      var shaderStage = hook.slice(0, 2);\n      var moduleInjections = this._moduleInjections[shaderStage];\n      moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n      moduleInjections[moduleName][hook] = {\n        injection: injection,\n        order: order\n      };\n      this.stateHash++;\n    }\n  }, {\n    key: \"addShaderHook\",\n    value: function addShaderHook(hook) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      hook = hook.trim();\n\n      var _hook$split = hook.split(':'),\n          _hook$split2 = _slicedToArray(_hook$split, 2),\n          stage = _hook$split2[0],\n          signature = _hook$split2[1];\n\n      var name = hook.replace(/\\(.+/, '');\n      this._hookFunctions[stage][name] = Object.assign(opts, {\n        signature: signature\n      });\n      this.stateHash++;\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      var _this = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _props$vs = props.vs,\n          vs = _props$vs === void 0 ? '' : _props$vs,\n          _props$fs = props.fs,\n          fs = _props$fs === void 0 ? '' : _props$fs,\n          _props$defines = props.defines,\n          defines = _props$defines === void 0 ? {} : _props$defines,\n          _props$inject = props.inject,\n          inject = _props$inject === void 0 ? {} : _props$inject,\n          _props$varyings = props.varyings,\n          varyings = _props$varyings === void 0 ? [] : _props$varyings,\n          _props$bufferMode = props.bufferMode,\n          bufferMode = _props$bufferMode === void 0 ? 0x8c8d : _props$bufferMode;\n\n      var modules = this._getModuleList(props.modules);\n\n      var vsHash = this._getHash(vs);\n\n      var fsHash = this._getHash(fs);\n\n      var moduleHashes = modules.map(function (m) {\n        return _this._getHash(typeof m === 'string' ? m : m.name);\n      }).sort();\n      var varyingHashes = varyings.map(function (v) {\n        return _this._getHash(v);\n      });\n      var defineKeys = Object.keys(defines).sort();\n      var injectKeys = Object.keys(inject).sort();\n      var defineHashes = [];\n      var injectHashes = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = defineKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          defineHashes.push(this._getHash(key));\n          defineHashes.push(this._getHash(defines[key]));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = injectKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _key = _step2.value;\n          injectHashes.push(this._getHash(_key));\n          injectHashes.push(this._getHash(inject[_key]));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var hash = \"\".concat(vsHash, \"/\").concat(fsHash, \"D\").concat(defineHashes.join('/'), \"M\").concat(moduleHashes.join('/'), \"I\").concat(injectHashes.join('/'), \"V\").concat(varyingHashes.join('/'), \"H\").concat(this.stateHash, \"B\").concat(bufferMode);\n\n      if (!this._programCache[hash]) {\n        var assembled = assembleShaders(this.gl, {\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          inject: inject,\n          defines: defines,\n          hookFunctions: this._hookFunctions,\n          moduleInjections: this._moduleInjections\n        });\n        this._programCache[hash] = new Program(this.gl, {\n          hash: hash,\n          vs: assembled.vs,\n          fs: assembled.fs,\n          varyings: varyings,\n          bufferMode: bufferMode\n        });\n\n        this._getUniforms[hash] = assembled.getUniforms || function (x) {};\n\n        this._useCounts[hash] = 0;\n      }\n\n      this._useCounts[hash]++;\n      return this._programCache[hash];\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms(program) {\n      return this._getUniforms[program.hash] || null;\n    }\n  }, {\n    key: \"release\",\n    value: function release(program) {\n      var hash = program.hash;\n      this._useCounts[hash]--;\n\n      if (this._useCounts[hash] === 0) {\n        this._programCache[hash][\"delete\"]();\n\n        delete this._programCache[hash];\n        delete this._getUniforms[hash];\n        delete this._useCounts[hash];\n      }\n    }\n  }, {\n    key: \"_getHash\",\n    value: function _getHash(key) {\n      if (this._hashes[key] === undefined) {\n        this._hashes[key] = this._hashCounter++;\n      }\n\n      return this._hashes[key];\n    }\n  }, {\n    key: \"_getModuleList\",\n    value: function _getModuleList() {\n      var appModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var modules = new Array(this._defaultModules.length + appModules.length);\n      var seen = {};\n      var count = 0;\n\n      for (var i = 0, len = this._defaultModules.length; i < len; ++i) {\n        var module = this._defaultModules[i];\n        var name = typeof module === 'string' ? module : module.name;\n        modules[count++] = module;\n        seen[name] = true;\n      }\n\n      for (var _i = 0, _len = appModules.length; _i < _len; ++_i) {\n        var _module = appModules[_i];\n\n        var _name = typeof _module === 'string' ? _module : _module.name;\n\n        if (!seen[_name]) {\n          modules[count++] = _module;\n          seen[_name] = true;\n        }\n      }\n\n      modules.length = count;\n      return modules;\n    }\n  }]);\n\n  return ProgramManager;\n}();\n\nexport { ProgramManager as default };","map":null,"metadata":{},"sourceType":"module"}
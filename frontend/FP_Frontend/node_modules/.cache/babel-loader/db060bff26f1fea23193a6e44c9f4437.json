{"ast":null,"code":"import { padTo4Bytes, assert } from '@loaders.gl/loader-utils';\nvar MAGIC_glTF = 0x676c5446;\nvar GLB_FILE_HEADER_SIZE = 12;\nvar GLB_CHUNK_HEADER_SIZE = 8;\nvar GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nvar GLB_CHUNK_TYPE_BIN = 0x004e4942;\nvar LE = true;\n\nfunction getMagicString(dataView) {\n  var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return \"\".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));\n}\n\nexport function isGLB(arrayBuffer) {\n  var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var dataView = new DataView(arrayBuffer);\n  var _options$magic = options.magic,\n      magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic;\n  var magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\nexport default function parseGLBSync(glb, arrayBuffer) {\n  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var dataView = new DataView(arrayBuffer);\n  glb.type = getMagicString(dataView, byteOffset + 0);\n  glb.version = dataView.getUint32(byteOffset + 4, LE);\n  var byteLength = dataView.getUint32(byteOffset + 8, LE);\n  glb.header = {\n    byteOffset: byteOffset,\n    byteLength: byteLength\n  };\n\n  if (glb.type !== 'glTF') {\n    console.warn(\"Invalid GLB magic string \".concat(glb.type));\n  }\n\n  assert(glb.version === 2, \"Invalid GLB version \".concat(glb.version, \". Only .glb v2 supported\"));\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  glb.json = {};\n  glb.hasBinChunk = false;\n  glb.binChunks = [];\n  parseGLBChunksSync(glb, dataView, byteOffset + 12, options);\n  addDeprecatedFields(glb);\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    var chunkLength = dataView.getUint32(byteOffset + 0, LE);\n    var chunkFormat = dataView.getUint32(byteOffset + 4, LE);\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n\n      default:\n        break;\n    }\n\n    switch (chunkFormat) {\n      case 0:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n\n        break;\n\n      case 1:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n\n        break;\n\n      default:\n    }\n\n    byteOffset += padTo4Bytes(chunkLength);\n  }\n\n  return byteOffset;\n}\n\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength, options) {\n  var jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n  var textDecoder = new TextDecoder('utf8');\n  var jsonText = textDecoder.decode(jsonChunk);\n  glb.json = JSON.parse(jsonText);\n}\n\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength, options) {\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset: byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n  });\n}\n\nfunction addDeprecatedFields(glb) {\n  glb.byteOffset = glb.header.byteOffset;\n  glb.magic = glb.header.magic;\n  glb.version = glb.header.version;\n  glb.byteLength = glb.header.byteLength;\n  glb.hasBinChunk = glb.binChunks.length >= 1;\n  glb.binChunkByteOffset = glb.header.hasBinChunk ? glb.binChunks[0].byteOffset : 0;\n  glb.binChunkLength = glb.header.hasBinChunk ? glb.binChunks[0].byteLength : 0;\n}","map":null,"metadata":{},"sourceType":"module"}
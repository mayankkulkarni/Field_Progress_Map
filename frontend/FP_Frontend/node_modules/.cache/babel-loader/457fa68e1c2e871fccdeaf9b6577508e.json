{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { Buffer } from '@luma.gl/core';\nimport assert from '../utils/assert';\nimport { createIterable } from '../utils/iterable-utils';\nimport { fillArray } from '../utils/flatten';\nimport * as range from '../utils/range';\nimport log from '../utils/log';\nimport BaseAttribute from './base-attribute';\nimport typedArrayManager from '../utils/typed-array-manager';\nimport { toDoublePrecisionArray } from '../utils/math-utils';\nimport { normalizeTransitionSettings } from './attribute-transition-utils';\nvar DEFAULT_STATE = {\n  isExternalBuffer: false,\n  lastExternalBuffer: null,\n  allocatedValue: null,\n  needsUpdate: true,\n  needsRedraw: false,\n  updateRanges: range.FULL\n};\n\nfunction addDoublePrecisionAttributes(attribute, shaderAttributeDefs) {\n  var doubleShaderAttributeDefs = {};\n\n  for (var shaderAttributeName in shaderAttributeDefs) {\n    var def = shaderAttributeDefs[shaderAttributeName];\n    var offset = 'offset' in def ? def.offset : attribute.offset;\n    var stride = 'stride' in def ? def.stride : attribute.size * 4;\n    doubleShaderAttributeDefs[\"\".concat(shaderAttributeName, \"32\")] = Object.assign({}, def, {\n      offset: offset,\n      stride: stride\n    });\n    doubleShaderAttributeDefs[\"\".concat(shaderAttributeName, \"64\")] = Object.assign({}, def, {\n      offset: offset * 2,\n      stride: stride * 2\n    });\n    doubleShaderAttributeDefs[\"\".concat(shaderAttributeName, \"64xyLow\")] = Object.assign({}, def, {\n      offset: offset * 2 + stride,\n      stride: stride * 2\n    });\n  }\n\n  return doubleShaderAttributeDefs;\n}\n\nvar Attribute = function (_BaseAttribute) {\n  _inherits(Attribute, _BaseAttribute);\n\n  function Attribute(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Attribute);\n\n    var logicalType = opts.type;\n    var doublePrecision = logicalType === 5130;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Attribute).call(this, gl, doublePrecision ? _objectSpread({}, opts, {\n      type: 5126\n    }) : opts));\n    var _opts$transition = opts.transition,\n        transition = _opts$transition === void 0 ? false : _opts$transition,\n        _opts$noAlloc = opts.noAlloc,\n        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,\n        _opts$update = opts.update,\n        update = _opts$update === void 0 ? null : _opts$update,\n        _opts$accessor = opts.accessor,\n        accessor = _opts$accessor === void 0 ? null : _opts$accessor,\n        _opts$transform = opts.transform,\n        transform = _opts$transform === void 0 ? null : _opts$transform,\n        _opts$bufferLayout = opts.bufferLayout,\n        bufferLayout = _opts$bufferLayout === void 0 ? null : _opts$bufferLayout;\n    var _opts$defaultValue = opts.defaultValue,\n        defaultValue = _opts$defaultValue === void 0 ? [0, 0, 0, 0] : _opts$defaultValue;\n    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];\n    _this.defaultType = logicalType || _this.type || 5126;\n    _this.shaderAttributes = {};\n    _this.hasShaderAttributes = false;\n    _this.doublePrecision = doublePrecision;\n\n    if (doublePrecision && opts.fp64 === false) {\n      _this.defaultType = 5126;\n    }\n\n    var shaderAttributes = opts.shaderAttributes || doublePrecision && _defineProperty({}, _this.id, {});\n\n    if (shaderAttributes) {\n      var shaderAttributeNames = Object.keys(shaderAttributes);\n      shaderAttributes = doublePrecision ? addDoublePrecisionAttributes(_assertThisInitialized(_this), shaderAttributes) : shaderAttributes;\n\n      for (var shaderAttributeName in shaderAttributes) {\n        var shaderAttribute = shaderAttributes[shaderAttributeName];\n        _this.shaderAttributes[shaderAttributeName] = new BaseAttribute(_this.gl, Object.assign({\n          size: _this.size,\n          normalized: _this.normalized,\n          integer: _this.integer,\n          offset: _this.offset,\n          stride: _this.stride,\n          divisor: _this.divisor\n        }, shaderAttribute, {\n          id: shaderAttributeName,\n          buffer: _this.getBuffer()\n        }));\n        _this.hasShaderAttributes = shaderAttributeNames;\n      }\n    }\n\n    Object.assign(_this.userData, DEFAULT_STATE, opts, {\n      transition: transition,\n      noAlloc: noAlloc,\n      update: update || accessor && _this._standardAccessor,\n      accessor: accessor,\n      transform: transform,\n      defaultValue: defaultValue,\n      bufferLayout: bufferLayout\n    });\n    Object.seal(_this.userData);\n\n    _this._validateAttributeUpdaters();\n\n    return _this;\n  }\n\n  _createClass(Attribute, [{\n    key: \"delete\",\n    value: function _delete() {\n      _get(_getPrototypeOf(Attribute.prototype), \"delete\", this).call(this);\n\n      typedArrayManager.release(this.userData.allocatedValue);\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      return this.userData.needsUpdate;\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$clearChangedFla = _ref2.clearChangedFlags,\n          clearChangedFlags = _ref2$clearChangedFla === void 0 ? false : _ref2$clearChangedFla;\n\n      var needsRedraw = this.userData.needsRedraw;\n      this.userData.needsRedraw = this.userData.needsRedraw && !clearChangedFlags;\n      return needsRedraw;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers() {\n      var accessor = this.userData.accessor;\n      return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor() {\n      return this.userData.accessor;\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes() {\n      var shaderAttributes = {};\n\n      if (this.doublePrecision) {\n        var isBuffer64Bit = this.value instanceof Float64Array;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.hasShaderAttributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var shaderAttributeName = _step.value;\n            shaderAttributes[shaderAttributeName] = this.shaderAttributes[isBuffer64Bit ? \"\".concat(shaderAttributeName, \"64\") : \"\".concat(shaderAttributeName, \"32\")];\n            var shaderAttributeLowPartName = \"\".concat(shaderAttributeName, \"64xyLow\");\n            shaderAttributes[shaderAttributeLowPartName] = isBuffer64Bit ? this.shaderAttributes[shaderAttributeLowPartName] : new Float32Array(this.size);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else if (this.hasShaderAttributes) {\n        Object.assign(shaderAttributes, this.shaderAttributes);\n      } else {\n        shaderAttributes[this.id] = this;\n      }\n\n      return shaderAttributes;\n    }\n  }, {\n    key: \"supportsTransition\",\n    value: function supportsTransition() {\n      return Boolean(this.userData.transition);\n    }\n  }, {\n    key: \"getTransitionSetting\",\n    value: function getTransitionSetting(opts) {\n      var accessor = this.userData.accessor;\n      var layerSettings = this.userData.transition;\n\n      if (!this.supportsTransition()) {\n        return null;\n      }\n\n      var userSettings = Array.isArray(accessor) ? opts[accessor.find(function (a) {\n        return opts[a];\n      })] : opts[accessor];\n      return normalizeTransitionSettings(userSettings, layerSettings);\n    }\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      var dataRange = arguments.length > 1 ? arguments[1] : undefined;\n      this.userData.needsUpdate = this.userData.needsUpdate || reason;\n\n      if (dataRange) {\n        var _dataRange$startRow = dataRange.startRow,\n            startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,\n            _dataRange$endRow = dataRange.endRow,\n            endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;\n        this.userData.updateRanges = range.add(this.userData.updateRanges, [startRow, endRow]);\n      } else {\n        this.userData.updateRanges = range.FULL;\n      }\n    }\n  }, {\n    key: \"clearNeedsUpdate\",\n    value: function clearNeedsUpdate() {\n      this.userData.needsUpdate = false;\n      this.userData.updateRanges = range.EMPTY;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      this.userData.needsRedraw = this.userData.needsRedraw || reason;\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(numInstances) {\n      var state = this.userData;\n\n      if (state.isExternalBuffer || state.noAlloc) {\n        return false;\n      }\n\n      if (state.update) {\n        assert(Number.isFinite(numInstances));\n        var allocCount = Math.max(numInstances, 1);\n        var ArrayType = glArrayFromType(this.defaultType);\n        var oldValue = state.allocatedValue;\n        var shouldCopy = state.updateRanges !== range.FULL;\n        this.constant = false;\n        this.value = typedArrayManager.allocate(oldValue, allocCount, {\n          size: this.size,\n          type: ArrayType,\n          padding: this.elementOffset,\n          copy: shouldCopy\n        });\n\n        if (this.buffer && this.buffer.byteLength < this.value.byteLength) {\n          this.buffer.reallocate(this.value.byteLength);\n\n          if (shouldCopy && oldValue) {\n            this.buffer.subData(oldValue);\n          }\n        }\n\n        state.allocatedValue = this.value;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(_ref3) {\n      var numInstances = _ref3.numInstances,\n          bufferLayout = _ref3.bufferLayout,\n          data = _ref3.data,\n          props = _ref3.props,\n          context = _ref3.context;\n\n      if (!this.needsUpdate()) {\n        return false;\n      }\n\n      var state = this.userData;\n      var update = state.update,\n          updateRanges = state.updateRanges,\n          noAlloc = state.noAlloc;\n      var updated = true;\n\n      if (update) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = updateRanges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n                startRow = _step2$value[0],\n                endRow = _step2$value[1];\n\n            update.call(context, this, {\n              data: data,\n              startRow: startRow,\n              endRow: endRow,\n              props: props,\n              numInstances: numInstances,\n              bufferLayout: bufferLayout\n            });\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        var doublePrecision = this.doublePrecision && this.value instanceof Float64Array;\n\n        if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength) {\n          var attributeValue = this.value;\n          this.update({\n            value: doublePrecision ? toDoublePrecisionArray(attributeValue, this) : attributeValue,\n            constant: this.constant\n          });\n          this.value = attributeValue;\n        } else {\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = updateRanges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var _step3$value = _slicedToArray(_step3.value, 2),\n                  startRow = _step3$value[0],\n                  endRow = _step3$value[1];\n\n              var startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n              var endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n              this.buffer.subData({\n                data: doublePrecision ? toDoublePrecisionArray(this.value, {\n                  size: this.size,\n                  startIndex: startOffset,\n                  endIndex: endOffset\n                }) : this.value.subarray(startOffset, endOffset),\n                offset: startOffset * this.value.BYTES_PER_ELEMENT\n              });\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n                _iterator3[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n\n        this._checkAttributeArray();\n      } else {\n        updated = false;\n      }\n\n      this._updateShaderAttributes();\n\n      this.clearNeedsUpdate();\n      state.needsRedraw = true;\n      return updated;\n    }\n  }, {\n    key: \"update\",\n    value: function update(props) {\n      _get(_getPrototypeOf(Attribute.prototype), \"update\", this).call(this, props);\n\n      this._updateShaderAttributes();\n    }\n  }, {\n    key: \"setConstantValue\",\n    value: function setConstantValue(value) {\n      var state = this.userData;\n\n      if (value === undefined || typeof value === 'function') {\n        state.isExternalBuffer = false;\n        return false;\n      }\n\n      value = this._normalizeValue(value);\n      var hasChanged = !this.constant || !this._areValuesEqual(value, this.value);\n\n      if (hasChanged) {\n        this.update({\n          constant: true,\n          value: value\n        });\n      }\n\n      state.needsRedraw = state.needsUpdate || hasChanged;\n      this.clearNeedsUpdate();\n      state.isExternalBuffer = true;\n      return true;\n    }\n  }, {\n    key: \"setExternalBuffer\",\n    value: function setExternalBuffer(buffer) {\n      var state = this.userData;\n\n      if (!buffer) {\n        state.isExternalBuffer = false;\n        state.lastExternalBuffer = null;\n        return false;\n      }\n\n      this.clearNeedsUpdate();\n\n      if (state.lastExternalBuffer === buffer) {\n        return true;\n      }\n\n      state.isExternalBuffer = true;\n      state.lastExternalBuffer = buffer;\n      var opts;\n\n      if (ArrayBuffer.isView(buffer)) {\n        opts = {\n          constant: false,\n          value: buffer\n        };\n      } else if (buffer instanceof Buffer) {\n        opts = {\n          constant: false,\n          buffer: buffer\n        };\n      } else {\n        opts = Object.assign({\n          constant: false\n        }, buffer);\n      }\n\n      this._checkExternalBuffer(opts);\n\n      if (this.doublePrecision && opts.value instanceof Float64Array) {\n        opts.originalValue = opts.value;\n        opts.value = toDoublePrecisionArray(opts.value, this);\n      }\n\n      this.update(opts);\n      state.needsRedraw = true;\n\n      if (opts.originalValue) {\n        this.value = opts.originalValue;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_checkExternalBuffer\",\n    value: function _checkExternalBuffer(opts) {\n      var value = opts.value;\n\n      if (!opts.constant && value) {\n        var ArrayType = glArrayFromType(this.defaultType);\n        var illegalArrayType = false;\n\n        if (this.doublePrecision) {\n          illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n        } else if (this.hasShaderAttributes) {\n          illegalArrayType = value.BYTES_PER_ELEMENT !== ArrayType.BYTES_PER_ELEMENT && Object.values(this.shaderAttributes).some(function (attribute) {\n            return attribute.offset || attribute.stride;\n          });\n        }\n\n        if (illegalArrayType) {\n          throw new Error(\"Attribute \".concat(this.id, \" does not support \").concat(value.constructor.name));\n        }\n\n        if (!(value instanceof ArrayType) && this.normalized && !('normalized' in opts)) {\n          log.warn(\"Attribute \".concat(this.id, \" is normalized\"))();\n        }\n      }\n    }\n  }, {\n    key: \"getVertexOffset\",\n    value: function getVertexOffset(row) {\n      var bufferLayout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bufferLayout;\n      var offset = this.elementOffset;\n\n      if (bufferLayout) {\n        var index = 0;\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = bufferLayout[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var geometrySize = _step4.value;\n\n            if (index >= row) {\n              break;\n            }\n\n            offset += geometrySize * this.size;\n            index++;\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        return offset;\n      }\n\n      return offset + row * this.size;\n    }\n  }, {\n    key: \"_normalizeValue\",\n    value: function _normalizeValue(value) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var defaultValue = this.userData.defaultValue;\n\n      if (!Array.isArray(value) && !ArrayBuffer.isView(value)) {\n        out[start] = Number.isFinite(value) ? value : defaultValue[0];\n        return out;\n      }\n\n      switch (this.size) {\n        case 4:\n          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n\n        case 3:\n          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n\n        case 2:\n          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n\n        case 1:\n          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n      }\n\n      return out;\n    }\n  }, {\n    key: \"_areValuesEqual\",\n    value: function _areValuesEqual(value1, value2) {\n      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.size;\n\n      for (var i = 0; i < size; i++) {\n        if (value1[i] !== value2[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_standardAccessor\",\n    value: function _standardAccessor(attribute, _ref4) {\n      var data = _ref4.data,\n          startRow = _ref4.startRow,\n          endRow = _ref4.endRow,\n          props = _ref4.props,\n          numInstances = _ref4.numInstances,\n          bufferLayout = _ref4.bufferLayout;\n      var state = attribute.userData;\n      var accessor = state.accessor,\n          transform = state.transform;\n      var value = attribute.value,\n          size = attribute.size;\n      var accessorFunc = typeof accessor === 'function' ? accessor : props[accessor];\n      assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n      var i = attribute.getVertexOffset(startRow, bufferLayout);\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = iterable[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var object = _step5.value;\n          objectInfo.index++;\n          var objectValue = accessorFunc(object, objectInfo);\n\n          if (transform) {\n            objectValue = transform.call(this, objectValue);\n          }\n\n          if (bufferLayout) {\n            attribute._normalizeValue(objectValue, objectInfo.target);\n\n            var numVertices = bufferLayout[objectInfo.index];\n            fillArray({\n              target: attribute.value,\n              source: objectInfo.target,\n              start: i,\n              count: numVertices\n            });\n            i += numVertices * size;\n          } else {\n            attribute._normalizeValue(objectValue, value, i);\n\n            i += size;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      attribute.constant = false;\n      attribute.bufferLayout = bufferLayout;\n    }\n  }, {\n    key: \"_validateAttributeUpdaters\",\n    value: function _validateAttributeUpdaters() {\n      var state = this.userData;\n      var hasUpdater = state.noAlloc || typeof state.update === 'function';\n\n      if (!hasUpdater) {\n        throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n      }\n    }\n  }, {\n    key: \"_checkAttributeArray\",\n    value: function _checkAttributeArray() {\n      var value = this.value;\n\n      if (value && value.length >= 4) {\n        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);\n\n        if (!valid) {\n          throw new Error(\"Illegal attribute generated for \".concat(this.id));\n        }\n      }\n    }\n  }, {\n    key: \"_updateShaderAttributes\",\n    value: function _updateShaderAttributes() {\n      var shaderAttributes = this.shaderAttributes;\n\n      for (var shaderAttributeName in shaderAttributes) {\n        var shaderAttribute = shaderAttributes[shaderAttributeName];\n        shaderAttribute.update({\n          buffer: this.getBuffer(),\n          value: this.value,\n          constant: this.constant\n        });\n      }\n    }\n  }, {\n    key: \"bufferLayout\",\n    get: function get() {\n      return this.userData.bufferLayout;\n    },\n    set: function set(layout) {\n      this.userData.bufferLayout = layout;\n    }\n  }]);\n\n  return Attribute;\n}(BaseAttribute);\n\nexport { Attribute as default };\n\nfunction glArrayFromType(glType) {\n  switch (glType) {\n    case 5126:\n      return Float32Array;\n\n    case 5130:\n      return Float64Array;\n\n    case 5123:\n    case 33635:\n    case 32819:\n    case 32820:\n      return Uint16Array;\n\n    case 5125:\n      return Uint32Array;\n\n    case 5121:\n      return Uint8ClampedArray;\n\n    case 5120:\n      return Int8Array;\n\n    case 5122:\n      return Int16Array;\n\n    case 5124:\n      return Int32Array;\n\n    default:\n      throw new Error('Failed to deduce type from array');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}
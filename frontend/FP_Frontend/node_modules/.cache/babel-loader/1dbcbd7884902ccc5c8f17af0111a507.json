{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { TextDecoder, fetchFile } from '@loaders.gl/core';\nimport { getFullUri } from '../gltf-utils/gltf-utils';\nimport { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';\nimport { KHR_DRACO_MESH_COMPRESSION, UBER_POINT_CLOUD_EXTENSION } from '../gltf-constants';\nimport GLBParser from './glb-parser';\nimport GLTFPostProcessorOld from './gltf-post-processor-old';\nvar DEFAULT_OPTIONS = {\n  fetchLinkedResources: true,\n  fetch: fetchFile,\n  decompress: false,\n  DracoLoader: null,\n  postProcess: true,\n  createImages: false,\n  log: console\n};\n\nvar GLTFParser = function () {\n  function GLTFParser() {\n    _classCallCheck(this, GLTFParser);\n  }\n\n  _createClass(GLTFParser, [{\n    key: \"parse\",\n    value: function () {\n      var _parse = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(gltf) {\n        var options,\n            postProcessor,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                options = Object.assign({}, DEFAULT_OPTIONS, options);\n                this.parseSync(gltf, _objectSpread({}, options, {\n                  postProcess: false,\n                  decompress: false\n                }));\n\n                if (!options.fetchLinkedResources) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 6;\n                return this._loadLinkedAssets(options);\n\n              case 6:\n                if (options.decompress) {\n                  this._decompressMeshes(options);\n                }\n\n                if (options.postProcess) {\n                  postProcessor = new GLTFPostProcessorOld();\n                  postProcessor.postProcess(this.gltf, this.glbParser, options);\n                }\n\n                return _context.abrupt(\"return\", this.gltf);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function parse(_x) {\n        return _parse.apply(this, arguments);\n      }\n\n      return parse;\n    }()\n  }, {\n    key: \"parseSync\",\n    value: function parseSync(gltf) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options = Object.assign({}, DEFAULT_OPTIONS, options);\n\n      if (gltf instanceof ArrayBuffer && !GLBParser.isGLB(gltf, options)) {\n        var textDecoder = new TextDecoder();\n        gltf = textDecoder.decode(gltf);\n      }\n\n      if (typeof gltf === 'string') {\n        gltf = JSON.parse(gltf);\n      }\n\n      if (gltf instanceof ArrayBuffer) {\n        this.glbParser = new GLBParser();\n        this.gltf = this.glbParser.parseSync(gltf).json;\n        this.json = this.gltf;\n      } else {\n        this.glbParser = null;\n        this.gltf = gltf;\n        this.json = gltf;\n      }\n\n      if (options.decompress) {\n        this._decompressMeshes(options);\n      }\n\n      if (options.postProcess) {\n        var postProcessor = new GLTFPostProcessorOld();\n        postProcessor.postProcess(this.gltf, this.glbParser, options);\n      }\n\n      return this.gltf;\n    }\n  }, {\n    key: \"getApplicationData\",\n    value: function getApplicationData(key) {\n      var data = this.json[key];\n      return data;\n    }\n  }, {\n    key: \"getExtraData\",\n    value: function getExtraData(key) {\n      var extras = this.json.extras || {};\n      return extras[key];\n    }\n  }, {\n    key: \"getExtension\",\n    value: function getExtension(extensionName) {\n      var isExtension = this.getUsedExtensions().find(function (name) {\n        return name === extensionName;\n      });\n      var extensions = this.json.extensions || {};\n      return isExtension ? extensions[extensionName] || true : null;\n    }\n  }, {\n    key: \"getRequiredExtension\",\n    value: function getRequiredExtension(extensionName) {\n      var isRequired = this.getRequiredExtensions().find(function (name) {\n        return name === extensionName;\n      });\n      return isRequired ? this.getExtension(extensionName) : null;\n    }\n  }, {\n    key: \"getRequiredExtensions\",\n    value: function getRequiredExtensions() {\n      return this.json.extensionsRequired || [];\n    }\n  }, {\n    key: \"getUsedExtensions\",\n    value: function getUsedExtensions() {\n      return this.json.extensionsUsed || [];\n    }\n  }, {\n    key: \"getScene\",\n    value: function getScene(index) {\n      return this._get('scenes', index);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this._get('nodes', index);\n    }\n  }, {\n    key: \"getSkin\",\n    value: function getSkin(index) {\n      return this._get('skins', index);\n    }\n  }, {\n    key: \"getMesh\",\n    value: function getMesh(index) {\n      return this._get('meshes', index);\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(index) {\n      return this._get('materials', index);\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(index) {\n      return this._get('accessors', index);\n    }\n  }, {\n    key: \"getCamera\",\n    value: function getCamera(index) {\n      return null;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(index) {\n      return this._get('textures', index);\n    }\n  }, {\n    key: \"getSampler\",\n    value: function getSampler(index) {\n      return this._get('samplers', index);\n    }\n  }, {\n    key: \"getImage\",\n    value: function getImage(index) {\n      return this._get('images', index);\n    }\n  }, {\n    key: \"getBufferView\",\n    value: function getBufferView(index) {\n      return this._get('bufferViews', index);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(index) {\n      return this._get('buffers', index);\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(array, index) {\n      if (_typeof(index) === 'object') {\n        return index;\n      }\n\n      var object = this.gltf[array] && this.gltf[array][index];\n\n      if (!object) {\n        console.warn(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n      }\n\n      return object;\n    }\n  }, {\n    key: \"_loadLinkedAssets\",\n    value: function () {\n      var _loadLinkedAssets2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(options) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return Promise.all(this.gltf.buffers.map(function (buffer) {\n                  return _this._loadBuffer(buffer, options);\n                }));\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _loadLinkedAssets(_x2) {\n        return _loadLinkedAssets2.apply(this, arguments);\n      }\n\n      return _loadLinkedAssets;\n    }()\n  }, {\n    key: \"_loadBuffer\",\n    value: function () {\n      var _loadBuffer2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(buffer, options) {\n        var fetch, uri, response, arrayBuffer;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(buffer.uri && options.uri)) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                fetch = options.fetch || window.fetch;\n                uri = getFullUri(buffer.uri, options.uri);\n                _context3.next = 5;\n                return fetch(uri);\n\n              case 5:\n                response = _context3.sent;\n                _context3.next = 8;\n                return response.arrayBuffer();\n\n              case 8:\n                arrayBuffer = _context3.sent;\n                buffer.data = arrayBuffer;\n                buffer.uri = null;\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function _loadBuffer(_x3, _x4) {\n        return _loadBuffer2.apply(this, arguments);\n      }\n\n      return _loadBuffer;\n    }()\n  }, {\n    key: \"_decompressMeshes\",\n    value: function _decompressMeshes(options) {\n      if (!options.DracoLoader || !options.decompress) {\n        return;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (this.gltf.meshes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var mesh = _step.value;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = mesh.primitives[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var primitive = _step2.value;\n\n              this._decompressKhronosDracoPrimitive(primitive, options);\n\n              this._decompressUberDracoPrimitive(primitive, options);\n\n              if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {\n                throw new Error('Empty glTF primitive: decompression failure?');\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n                _iterator2[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._removeExtension(KHR_DRACO_MESH_COMPRESSION);\n\n      this._removeExtension(UBER_POINT_CLOUD_EXTENSION);\n    }\n  }, {\n    key: \"_decompressKhronosDracoPrimitive\",\n    value: function _decompressKhronosDracoPrimitive(primitive, options) {\n      var compressedMesh = primitive.extensions && primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n      if (!compressedMesh) {\n        return;\n      }\n\n      delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n      var buffer = this._getBufferViewArray(compressedMesh.bufferView);\n\n      var decodedData = options.DracoLoader.parseSync(buffer);\n      primitive.attributes = getGLTFAccessors(decodedData.attributes);\n\n      if (decodedData.indices) {\n        primitive.indices = getGLTFAccessor(decodedData.indices);\n      }\n    }\n  }, {\n    key: \"_decompressUberDracoPrimitive\",\n    value: function _decompressUberDracoPrimitive(primitive, options) {\n      var compressedMesh = primitive.extensions && primitive.extensions[UBER_POINT_CLOUD_EXTENSION];\n\n      if (!compressedMesh) {\n        return;\n      }\n\n      if (primitive.mode !== 0) {\n        throw new Error(UBER_POINT_CLOUD_EXTENSION);\n      }\n\n      delete primitive.extensions[UBER_POINT_CLOUD_EXTENSION];\n\n      var buffer = this._getBufferViewArray(compressedMesh.bufferView);\n\n      var decodedData = options.DracoLoader.parseSync(buffer);\n      primitive.attributes = decodedData.attributes;\n    }\n  }, {\n    key: \"_getBufferViewArray\",\n    value: function _getBufferViewArray(bufferViewIndex) {\n      var bufferView = this.gltf.bufferViews[bufferViewIndex];\n\n      if (this.glbParser) {\n        return this.glbParser.getBufferView(bufferView);\n      }\n\n      var buffer = this.gltf.buffers[bufferView.buffer].data;\n      var byteOffset = bufferView.byteOffset || 0;\n      return new Uint8Array(buffer, byteOffset, bufferView.byteLength);\n    }\n  }, {\n    key: \"_removeExtension\",\n    value: function _removeExtension(extensionName) {\n      if (this.json.extensionsRequired) {\n        this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n      }\n\n      if (this.json.extensionsUsed) {\n        this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n      }\n\n      if (this.json.extensions) {\n        delete this.json.extensions[extensionName];\n      }\n    }\n  }, {\n    key: \"_removeStringFromArray\",\n    value: function _removeStringFromArray(array, string) {\n      var found = true;\n\n      while (found) {\n        var index = array.indexOf(string);\n\n        if (index > -1) {\n          array.splice(index, 1);\n        } else {\n          found = false;\n        }\n      }\n    }\n  }]);\n\n  return GLTFParser;\n}();\n\nexport { GLTFParser as default };","map":null,"metadata":{},"sourceType":"module"}
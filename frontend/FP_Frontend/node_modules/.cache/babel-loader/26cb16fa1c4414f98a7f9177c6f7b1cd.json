{"ast":null,"code":"export function flattenToTypedArray(nestedArray) {\n  var ArrayType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Float32Array;\n\n  if (nestedArray.length === 0) {\n    return new Float32Array(0);\n  }\n\n  if (!checkVertices(nestedArray)) {\n    return null;\n  }\n\n  var count = countVertices(nestedArray);\n  var typedArray = new ArrayType(count);\n  flattenVerticesInPlace(nestedArray, typedArray);\n  return typedArray;\n}\n\nfunction countVertices(nestedArray) {\n  var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var nestedCount = 0;\n  var localCount = 0;\n  var index = -1;\n\n  while (++index < nestedArray.length) {\n    var value = nestedArray[index];\n\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      nestedCount += countVertices(value);\n    } else {\n      localCount++;\n    }\n  }\n\n  return nestedCount + (nestedCount === 0 && localCount < dimensions ? dimensions : localCount);\n}\n\nfunction checkVertices(nestedArray) {\n  var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.isFinite;\n  var index = -1;\n\n  while (++index < nestedArray.length) {\n    var value = nestedArray[index];\n\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      if (!checkVertices(value, predicate)) {\n        return false;\n      }\n    } else if (!predicate(value)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction flattenVerticesInPlace(nestedArray, result) {\n  var dimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n  flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, 0);\n  return result;\n}\n\nfunction flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, insert) {\n  var index = -1;\n  var vertexLength = 0;\n\n  while (++index < nestedArray.length) {\n    var value = nestedArray[index];\n\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      insert = flattenVerticesInPlaceRecursive(value, result, dimensions, insert);\n    } else {\n      if (vertexLength < dimensions) {\n        result[insert++] = value;\n        vertexLength++;\n      }\n    }\n  }\n\n  if (vertexLength > 0 && vertexLength < dimensions) {\n    result[insert++] = 0;\n  }\n\n  return insert;\n}","map":null,"metadata":{},"sourceType":"module"}
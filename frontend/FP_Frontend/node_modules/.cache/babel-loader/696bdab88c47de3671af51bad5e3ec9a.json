{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _SHADER_TYPE, _HOOK_FUNCTIONS, _MODULE_INJECTIONS;\n\nimport { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';\nimport { resolveModules, getShaderModule } from './resolve-modules';\nimport { getPlatformShaderDefines, getVersionDefines } from './platform-defines';\nimport injectShader, { DECLARATION_INJECT_MARKER } from './inject-shader';\nimport { assert } from '../utils';\nvar INJECT_SHADER_DECLARATIONS = \"\\n\\n\".concat(DECLARATION_INJECT_MARKER, \"\\n\\n\");\nvar SHADER_TYPE = (_SHADER_TYPE = {}, _defineProperty(_SHADER_TYPE, VERTEX_SHADER, 'vertex'), _defineProperty(_SHADER_TYPE, FRAGMENT_SHADER, 'fragment'), _SHADER_TYPE);\nvar HOOK_FUNCTIONS = (_HOOK_FUNCTIONS = {}, _defineProperty(_HOOK_FUNCTIONS, VERTEX_SHADER, {}), _defineProperty(_HOOK_FUNCTIONS, FRAGMENT_SHADER, {}), _HOOK_FUNCTIONS);\nvar MODULE_INJECTIONS = (_MODULE_INJECTIONS = {}, _defineProperty(_MODULE_INJECTIONS, VERTEX_SHADER, {}), _defineProperty(_MODULE_INJECTIONS, FRAGMENT_SHADER, {}), _MODULE_INJECTIONS);\nvar FRAGMENT_SHADER_PROLOGUE = \"precision highp float;\\n\\n\";\nexport function createShaderHook(hook) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  hook = hook.trim();\n\n  var _hook$split = hook.split(':'),\n      _hook$split2 = _slicedToArray(_hook$split, 2),\n      stage = _hook$split2[0],\n      signature = _hook$split2[1];\n\n  var name = hook.replace(/\\(.+/, '');\n  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {\n    signature: signature\n  });\n}\nexport function createModuleInjection(moduleName, opts) {\n  var hook = opts.hook,\n      injection = opts.injection,\n      _opts$order = opts.order,\n      order = _opts$order === void 0 ? 0 : _opts$order;\n  var shaderStage = hook.slice(0, 2);\n  var moduleInjections = MODULE_INJECTIONS[shaderStage];\n  moduleInjections[moduleName] = moduleInjections[moduleName] || {};\n  assert(!moduleInjections[moduleName][hook], 'Module injection already created');\n  moduleInjections[moduleName][hook] = {\n    injection: injection,\n    order: order\n  };\n}\nexport function resetGlobalShaderHooks() {\n  HOOK_FUNCTIONS[VERTEX_SHADER] = {};\n  HOOK_FUNCTIONS[FRAGMENT_SHADER] = {};\n  MODULE_INJECTIONS[VERTEX_SHADER] = {};\n  MODULE_INJECTIONS[FRAGMENT_SHADER] = {};\n}\nexport function assembleShaders(gl, opts) {\n  var vs = opts.vs,\n      fs = opts.fs;\n  var modules = resolveModules(opts.modules || []);\n  return {\n    gl: gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {\n      source: vs,\n      type: VERTEX_SHADER,\n      modules: modules\n    })),\n    fs: assembleShader(gl, Object.assign({}, opts, {\n      source: fs,\n      type: FRAGMENT_SHADER,\n      modules: modules\n    })),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\nfunction assembleShader(gl, _ref) {\n  var id = _ref.id,\n      source = _ref.source,\n      type = _ref.type,\n      modules = _ref.modules,\n      _ref$defines = _ref.defines,\n      defines = _ref$defines === void 0 ? {} : _ref$defines,\n      _ref$hookFunctions = _ref.hookFunctions,\n      hookFunctions = _ref$hookFunctions === void 0 ? HOOK_FUNCTIONS : _ref$hookFunctions,\n      _ref$moduleInjections = _ref.moduleInjections,\n      moduleInjections = _ref$moduleInjections === void 0 ? MODULE_INJECTIONS : _ref$moduleInjections,\n      _ref$inject = _ref.inject,\n      inject = _ref$inject === void 0 ? {} : _ref$inject,\n      _ref$prologue = _ref.prologue,\n      prologue = _ref$prologue === void 0 ? true : _ref$prologue,\n      log = _ref.log;\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  if (hookFunctions !== HOOK_FUNCTIONS) {\n    var _hookFunctions;\n\n    hookFunctions = (_hookFunctions = {}, _defineProperty(_hookFunctions, VERTEX_SHADER, Object.assign({}, HOOK_FUNCTIONS[VERTEX_SHADER], hookFunctions[VERTEX_SHADER])), _defineProperty(_hookFunctions, FRAGMENT_SHADER, Object.assign({}, HOOK_FUNCTIONS[FRAGMENT_SHADER], hookFunctions[FRAGMENT_SHADER])), _hookFunctions);\n  }\n\n  if (moduleInjections !== MODULE_INJECTIONS) {\n    var _moduleInjections;\n\n    moduleInjections = (_moduleInjections = {}, _defineProperty(_moduleInjections, VERTEX_SHADER, Object.assign({}, MODULE_INJECTIONS[VERTEX_SHADER], moduleInjections[VERTEX_SHADER])), _defineProperty(_moduleInjections, FRAGMENT_SHADER, Object.assign({}, MODULE_INJECTIONS[FRAGMENT_SHADER], moduleInjections[FRAGMENT_SHADER])), _moduleInjections);\n  }\n\n  var isVertex = type === VERTEX_SHADER;\n  var sourceLines = source.split('\\n');\n  var glslVersion = 100;\n  var versionLine = '';\n  var coreSource = source;\n\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300;\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = \"#version \".concat(glslVersion);\n  }\n\n  var allDefines = {};\n  modules.forEach(function (module) {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n  var assembledSource = prologue ? \"\".concat(versionLine, \"\\n\").concat(getShaderName({\n    id: id,\n    source: source,\n    type: type\n  }), \"\\n\").concat(getShaderType({\n    type: type\n  }), \"\\n\").concat(getPlatformShaderDefines(gl), \"\\n\").concat(getVersionDefines(gl, glslVersion, !isVertex), \"\\n\").concat(getApplicationDefines(allDefines), \"\\n\").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, \"\\n\") : \"\".concat(versionLine, \"\\n\");\n  var injectStandardStubs = false;\n  var hookInjections = {};\n  var mainInjections = {};\n\n  for (var key in inject) {\n    var injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n\n    if (key.match(/^(v|f)s:/)) {\n      if (key[3] === '#') {\n        mainInjections[key] = [injection];\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      mainInjections[key] = [injection];\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var module = _step.value;\n\n      switch (module.name) {\n        case 'inject':\n          injectStandardStubs = true;\n          break;\n\n        default:\n          if (log) {\n            module.checkDeprecations(coreSource, log);\n          }\n\n          var moduleSource = module.getModuleSource(type, glslVersion);\n          assembledSource += moduleSource;\n\n          if (moduleInjections[type][module.name]) {\n            var injections = moduleInjections[type][module.name];\n\n            for (var _key in injections) {\n              if (_key.match(/^(v|f)s:#/)) {\n                mainInjections[_key] = mainInjections[_key] || [];\n\n                mainInjections[_key].push(injections[_key]);\n              } else {\n                hookInjections[_key] = hookInjections[_key] || [];\n\n                hookInjections[_key].push(injections[_key]);\n              }\n            }\n          }\n\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);\n  assembledSource += coreSource;\n  assembledSource = injectShader(assembledSource, type, mainInjections, injectStandardStubs);\n  return assembledSource;\n}\n\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    var uniforms = {};\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var module = _step2.value;\n        var moduleUniforms = module.getUniforms(opts, uniforms);\n        Object.assign(uniforms, moduleUniforms);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return uniforms;\n  };\n}\n\nfunction assembleModuleMap(modules) {\n  var result = {};\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var moduleName = _step3.value;\n      var shaderModule = getShaderModule(moduleName);\n      result[moduleName] = shaderModule;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n        _iterator3[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getShaderType(_ref2) {\n  var type = _ref2.type;\n  return \"\\n#define SHADER_TYPE_\".concat(SHADER_TYPE[type].toUpperCase(), \"\\n\");\n}\n\nfunction getShaderName(_ref3) {\n  var id = _ref3.id,\n      source = _ref3.source,\n      type = _ref3.type;\n  var injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? \"\\n#define SHADER_NAME \".concat(id, \"_\").concat(SHADER_TYPE[type], \"\\n\\n\") : '';\n}\n\nfunction getApplicationDefines() {\n  var defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var count = 0;\n  var sourceText = '';\n\n  for (var define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n\n    count++;\n    var value = defines[define];\n\n    if (value || Number.isFinite(value)) {\n      sourceText += \"#define \".concat(define.toUpperCase(), \" \").concat(defines[define], \"\\n\");\n    }\n  }\n\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  var result = '';\n\n  for (var hookName in hookFunctions) {\n    var hookFunction = hookFunctions[hookName];\n    result += \"void \".concat(hookFunction.signature, \" {\\n\");\n\n    if (hookFunction.header) {\n      result += \"  \".concat(hookFunction.header);\n    }\n\n    if (hookInjections[hookName]) {\n      var injections = hookInjections[hookName];\n      injections.sort(function (a, b) {\n        return a.order - b.order;\n      });\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = injections[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var injection = _step4.value;\n          result += \"  \".concat(injection.injection, \"\\n\");\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    if (hookFunction.footer) {\n      result += \"  \".concat(hookFunction.footer);\n    }\n\n    result += '}\\n';\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}
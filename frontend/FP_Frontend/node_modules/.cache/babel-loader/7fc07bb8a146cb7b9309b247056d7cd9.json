{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport assert from './utils/assert';\nimport { getFullUri } from './gltf-utils/gltf-utils';\nimport { decodeExtensions, decodeExtensionsSync } from './extensions/extensions';\nimport parseGLBSync, { isGLB } from './parse-glb';\nimport postProcessGLTF from './post-process-gltf';\nvar DEFAULT_OPTIONS = {\n  fetchLinkedResources: true,\n  fetchImages: false,\n  createImages: false,\n  decompress: false,\n  postProcess: false,\n  log: console\n};\nexport function isGLTF(arrayBuffer) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var dataView = new DataView(arrayBuffer);\n  var byteOffset = 0;\n  return isGLB(dataView, byteOffset);\n}\nexport function parseGLTF(_x, _x2) {\n  return _parseGLTF.apply(this, arguments);\n}\n\nfunction _parseGLTF() {\n  _parseGLTF = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(gltf, arrayBufferOrString) {\n    var byteOffset,\n        options,\n        context,\n        promises,\n        _promise,\n        promise,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteOffset = _args.length > 2 && _args[2] !== undefined ? _args[2] : 0;\n            options = _args.length > 3 ? _args[3] : undefined;\n            context = _args.length > 4 ? _args[4] : undefined;\n            options = _objectSpread({}, DEFAULT_OPTIONS, {}, options.gltf);\n            parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n            promises = [];\n\n            if (options.fetchImages) {\n              _promise = fetchImages(gltf, options, context);\n              promises.push(_promise);\n            }\n\n            if (!options.fetchLinkedResources) {\n              _context.next = 10;\n              break;\n            }\n\n            _context.next = 10;\n            return fetchBuffers(gltf, options, context);\n\n          case 10:\n            promise = decodeExtensions(gltf, options, context);\n            promises.push(promise);\n            _context.next = 14;\n            return Promise.all(promises);\n\n          case 14:\n            return _context.abrupt(\"return\", options.postProcess ? postProcessGLTF(gltf, options) : gltf);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseGLTF.apply(this, arguments);\n}\n\nexport function parseGLTFSync(gltf, arrayBufferOrString) {\n  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var options = arguments.length > 3 ? arguments[3] : undefined;\n  var context = arguments.length > 4 ? arguments[4] : undefined;\n  options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  if (options.fetchLinkedResources) {\n    fetchBuffersSync(gltf, options);\n  }\n\n  if (options.decodeExtensions) {\n    decodeExtensionsSync(gltf, options);\n  }\n\n  return options.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    var textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    gltf.json = JSON.parse(data);\n  } else if (data instanceof ArrayBuffer) {\n    gltf._glb = {};\n    byteOffset = parseGLBSync(gltf._glb, data, byteOffset, options);\n    gltf.json = gltf._glb.json;\n  } else {\n    gltf.json = data;\n  }\n\n  var buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill({});\n\n  if (gltf._glb && gltf._glb.hasBinChunk) {\n    gltf.buffers[0] = {\n      arrayBuffer: gltf._glb.binChunks[0].arrayBuffer,\n      byteOffset: gltf._glb.binChunks[0].byteOffset,\n      byteLength: gltf._glb.binChunks[0].byteLength\n    };\n    gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  var images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\nfunction fetchBuffers(_x3, _x4, _x5) {\n  return _fetchBuffers.apply(this, arguments);\n}\n\nfunction _fetchBuffers() {\n  _fetchBuffers = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(gltf, options, context) {\n    var i, buffer, fetch, uri, response, arrayBuffer;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < gltf.json.buffers.length)) {\n              _context2.next = 21;\n              break;\n            }\n\n            buffer = gltf.json.buffers[i];\n\n            if (!buffer.uri) {\n              _context2.next = 18;\n              break;\n            }\n\n            if (options.uri) {\n              _context2.next = 7;\n              break;\n            }\n\n            console.warn('options.uri must be set to decode embedded glTF buffers');\n            return _context2.abrupt(\"return\");\n\n          case 7:\n            fetch = context.fetch;\n            assert(fetch);\n            uri = getFullUri(buffer.uri, options.uri);\n            _context2.next = 12;\n            return fetch(uri);\n\n          case 12:\n            response = _context2.sent;\n            _context2.next = 15;\n            return response.arrayBuffer();\n\n          case 15:\n            arrayBuffer = _context2.sent;\n            gltf.buffers[i] = {\n              arrayBuffer: arrayBuffer,\n              byteOffset: 0,\n              byteLength: arrayBuffer.byteLength\n            };\n            delete buffer.uri;\n\n          case 18:\n            ++i;\n            _context2.next = 1;\n            break;\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _fetchBuffers.apply(this, arguments);\n}\n\nfunction fetchBuffersSync(gltf, options) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (gltf.json.buffers || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var buffer = _step.value;\n\n      if (buffer.uri) {\n        throw new Error('parseGLTFSync: Cannot decode uri buffers');\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction fetchImages(_x6, _x7, _x8) {\n  return _fetchImages.apply(this, arguments);\n}\n\nfunction _fetchImages() {\n  _fetchImages = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(gltf, options, context) {\n    var images, promises, i, image;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            images = gltf.json.images || [];\n            promises = [];\n\n            for (i = 0; i < images.length; ++i) {\n              image = images[i];\n\n              if ('uri' in image) {\n                promises.push(fetchAndParseLinkedImage(gltf, image, i, options));\n              }\n            }\n\n            _context3.next = 5;\n            return Promise.all(promises);\n\n          case 5:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _fetchImages.apply(this, arguments);\n}\n\nfunction fetchAndParseLinkedImage(_x9, _x10, _x11, _x12, _x13) {\n  return _fetchAndParseLinkedImage.apply(this, arguments);\n}\n\nfunction _fetchAndParseLinkedImage() {\n  _fetchAndParseLinkedImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(gltf, image, i, options, context) {\n    var uri;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            uri = getFullUri(image.uri, options.uri);\n            _context4.next = 3;\n            return new Promise(function (resolve, reject) {\n              var img = new Image();\n              img.crossOrigin = 'anonymous';\n\n              img.onload = function () {\n                return resolve(img);\n              };\n\n              img.onerror = function (error) {\n                return reject(error);\n              };\n\n              img.src = uri;\n            });\n\n          case 3:\n            gltf.images[i] = _context4.sent;\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _fetchAndParseLinkedImage.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}
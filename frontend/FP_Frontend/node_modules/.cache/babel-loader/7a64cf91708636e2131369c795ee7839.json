{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { assert, log } from '@luma.gl/core';\nimport { Matrix4, Quaternion } from 'math.gl';\nexport var ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nexport var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    var ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    var components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    var length = components * accessor.count;\n    var _accessor$bufferView$ = accessor.bufferView.data,\n        buffer = _accessor$bufferView$.buffer,\n        byteOffset = _accessor$bufferView$.byteOffset;\n    var array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      var slicedArray = [];\n\n      for (var i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\nvar helperMatrix = new Matrix4();\n\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    var rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nvar quaternion = new Quaternion();\n\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    quaternion.slerp({\n      start: start,\n      target: stop,\n      ratio: ratio\n    });\n\n    for (var i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    for (var _i = 0; _i < start.length; _i++) {\n      target[path][_i] = ratio * stop[_i] + (1 - ratio) * start[_i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, _ref) {\n  var p0 = _ref.p0,\n      outTangent0 = _ref.outTangent0,\n      inTangent1 = _ref.inTangent1,\n      p1 = _ref.p1,\n      tDiff = _ref.tDiff,\n      t = _ref.ratio;\n\n  for (var i = 0; i < target[path].length; i++) {\n    var m0 = outTangent0[i] * tDiff;\n    var m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (var i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, _ref2, target, path) {\n  var input = _ref2.input,\n      interpolation = _ref2.interpolation,\n      output = _ref2.output;\n  var maxTime = input[input.length - 1];\n  var animationTime = time % maxTime;\n  var nextIndex = input.findIndex(function (t) {\n    return t >= animationTime;\n  });\n  var previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(\"Bad animation path \".concat(path))();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  var previousTime = input[previousIndex];\n  var nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        var ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        var _ratio = (animationTime - previousTime) / (nextTime - previousTime);\n\n        var tDiff = nextTime - previousTime;\n        var p0 = output[3 * previousIndex + 1];\n        var outTangent0 = output[3 * previousIndex + 2];\n        var inTangent1 = output[3 * nextIndex + 0];\n        var p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0: p0,\n          outTangent0: outTangent0,\n          inTangent1: inTangent1,\n          p1: p1,\n          tDiff: tDiff,\n          ratio: _ratio\n        });\n      }\n\n      break;\n\n    default:\n      log.warn(\"Interpolation \".concat(interpolation, \" not supported\"))();\n      break;\n  }\n}\n\nvar GLTFAnimation = function () {\n  function GLTFAnimation(props) {\n    _classCallCheck(this, GLTFAnimation);\n\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    Object.assign(this, props);\n  }\n\n  _createClass(GLTFAnimation, [{\n    key: \"animate\",\n    value: function animate(timeMs) {\n      if (!this.playing) {\n        return;\n      }\n\n      var absTime = timeMs / 1000;\n      var time = (absTime - this.startTime) * this.speed;\n      this.channels.forEach(function (_ref3) {\n        var sampler = _ref3.sampler,\n            target = _ref3.target,\n            path = _ref3.path;\n        interpolate(time, sampler, target, path);\n        applyTranslationRotationScale(target, target._node);\n      });\n    }\n  }]);\n\n  return GLTFAnimation;\n}();\n\nvar GLTFAnimator = function () {\n  function GLTFAnimator(gltf) {\n    _classCallCheck(this, GLTFAnimator);\n\n    this.animations = gltf.animations.map(function (animation, index) {\n      var name = animation.name || \"Animation-\".concat(index);\n      var samplers = animation.samplers.map(function (_ref4) {\n        var input = _ref4.input,\n            _ref4$interpolation = _ref4.interpolation,\n            interpolation = _ref4$interpolation === void 0 ? 'LINEAR' : _ref4$interpolation,\n            output = _ref4.output;\n        return {\n          input: accessorToJsArray(gltf.accessors[input]),\n          interpolation: interpolation,\n          output: accessorToJsArray(gltf.accessors[output])\n        };\n      });\n      var channels = animation.channels.map(function (_ref5) {\n        var sampler = _ref5.sampler,\n            target = _ref5.target;\n        return {\n          sampler: samplers[sampler],\n          target: gltf.nodes[target.node],\n          path: target.path\n        };\n      });\n      return new GLTFAnimation({\n        name: name,\n        channels: channels\n      });\n    });\n  }\n\n  _createClass(GLTFAnimator, [{\n    key: \"animate\",\n    value: function animate(time) {\n      this.setTime(time);\n    }\n  }, {\n    key: \"setTime\",\n    value: function setTime(time) {\n      this.animations.forEach(function (animation) {\n        return animation.animate(time);\n      });\n    }\n  }, {\n    key: \"getAnimations\",\n    value: function getAnimations() {\n      return this.animations;\n    }\n  }]);\n\n  return GLTFAnimator;\n}();\n\nexport { GLTFAnimator as default };","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Texture2D, log } from '@luma.gl/core';\n\nvar GLTFMaterialParser = function () {\n  function GLTFMaterialParser(gl, _ref) {\n    var attributes = _ref.attributes,\n        material = _ref.material,\n        pbrDebug = _ref.pbrDebug,\n        imageBasedLightingEnvironment = _ref.imageBasedLightingEnvironment,\n        lights = _ref.lights,\n        useTangents = _ref.useTangents;\n\n    _classCallCheck(this, GLTFMaterialParser);\n\n    this.gl = gl;\n    this.defines = {\n      USE_TEX_LOD: 1,\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n    this.uniforms = {\n      u_Camera: [0, 0, 0],\n      u_MetallicRoughnessValues: [1, 1]\n    };\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  _createClass(GLTFMaterialParser, [{\n    key: \"defineIfPresent\",\n    value: function defineIfPresent(value, name) {\n      if (value) {\n        this.defines[name] = 1;\n      }\n    }\n  }, {\n    key: \"parseTexture\",\n    value: function parseTexture(gltfTexture, name) {\n      var define = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};\n      var texture = new Texture2D(this.gl, {\n        id: gltfTexture.name || gltfTexture.id,\n        parameters: parameters,\n        pixelStore: _defineProperty({}, this.gl.UNPACK_FLIP_Y_WEBGL, false),\n        data: gltfTexture.texture.source.getImageAsync()\n      });\n      this.uniforms[name] = texture;\n      this.defineIfPresent(define, define);\n      this.generatedTextures.push(texture);\n    }\n  }, {\n    key: \"parsePbrMetallicRoughness\",\n    value: function parsePbrMetallicRoughness(pbrMetallicRoughness) {\n      if (pbrMetallicRoughness.baseColorTexture) {\n        this.parseTexture(pbrMetallicRoughness.baseColorTexture, 'u_BaseColorSampler', 'HAS_BASECOLORMAP');\n      }\n\n      this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n      if (pbrMetallicRoughness.metallicRoughnessTexture) {\n        this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, 'u_MetallicRoughnessSampler', 'HAS_METALROUGHNESSMAP');\n      }\n\n      var _pbrMetallicRoughness = pbrMetallicRoughness.metallicFactor,\n          metallicFactor = _pbrMetallicRoughness === void 0 ? 1 : _pbrMetallicRoughness,\n          _pbrMetallicRoughness2 = pbrMetallicRoughness.roughnessFactor,\n          roughnessFactor = _pbrMetallicRoughness2 === void 0 ? 1 : _pbrMetallicRoughness2;\n      this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n    }\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(material) {\n      if (material.pbrMetallicRoughness) {\n        this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n      }\n\n      if (material.normalTexture) {\n        this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n        var _material$normalTextu = material.normalTexture.scale,\n            scale = _material$normalTextu === void 0 ? 1 : _material$normalTextu;\n        this.uniforms.u_NormalScale = scale;\n      }\n\n      if (material.occlusionTexture) {\n        this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n        var _material$occlusionTe = material.occlusionTexture.strength,\n            strength = _material$occlusionTe === void 0 ? 1 : _material$occlusionTe;\n        this.uniforms.u_OcclusionStrength = strength;\n      }\n\n      if (material.emissiveTexture) {\n        this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n        this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n      }\n\n      if (material.alphaMode === 'MASK') {\n        var _material$alphaCutoff = material.alphaCutoff,\n            alphaCutoff = _material$alphaCutoff === void 0 ? 0.5 : _material$alphaCutoff;\n        this.defines.ALPHA_CUTOFF = 1;\n        this.uniforms.u_AlphaCutoff = alphaCutoff;\n      } else if (material.alphaMode === 'BLEND') {\n        log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n        Object.assign(this.parameters, {\n          blend: true,\n          blendEquation: this.gl.FUNC_ADD,\n          blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]\n        });\n      }\n    }\n  }]);\n\n  return GLTFMaterialParser;\n}();\n\nexport { GLTFMaterialParser as default };","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport * as Polygon from './polygon';\nimport { experimental } from '@deck.gl/core';\nvar Tesselator = experimental.Tesselator;\n\nvar PolygonTesselator = function (_Tesselator) {\n  _inherits(PolygonTesselator, _Tesselator);\n\n  function PolygonTesselator(_ref) {\n    var data = _ref.data,\n        getGeometry = _ref.getGeometry,\n        fp64 = _ref.fp64,\n        positionFormat = _ref.positionFormat,\n        _ref$IndexType = _ref.IndexType,\n        IndexType = _ref$IndexType === void 0 ? Uint32Array : _ref$IndexType;\n\n    _classCallCheck(this, PolygonTesselator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonTesselator).call(this, {\n      data: data,\n      getGeometry: getGeometry,\n      positionFormat: positionFormat,\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    }));\n  }\n\n  _createClass(PolygonTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      if (attributeName === 'indices') {\n        return this.attributes.indices.subarray(0, this.vertexCount);\n      }\n\n      return this.attributes[attributeName];\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(polygon) {\n      return Polygon.getVertexCount(polygon, this.positionSize);\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(polygon, context) {\n      polygon = Polygon.normalize(polygon, this.positionSize, context.geometrySize);\n\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n    }\n  }, {\n    key: \"_updateIndices\",\n    value: function _updateIndices(polygon, _ref2) {\n      var geometryIndex = _ref2.geometryIndex,\n          offset = _ref2.vertexStart,\n          indexStart = _ref2.indexStart;\n      var attributes = this.attributes,\n          indexLayout = this.indexLayout,\n          typedArrayManager = this.typedArrayManager;\n      var target = attributes.indices;\n      var i = indexStart;\n      var indices = Polygon.getSurfaceIndices(polygon, this.positionSize);\n      target = typedArrayManager.allocate(target, indexStart + indices.length, {\n        copy: true\n      });\n\n      for (var j = 0; j < indices.length; j++) {\n        target[i++] = indices[j] + offset;\n      }\n\n      indexLayout[geometryIndex] = indices.length;\n      attributes.indices = target;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(polygon, _ref3) {\n      var vertexStart = _ref3.vertexStart,\n          geometrySize = _ref3.geometrySize;\n      var _this$attributes = this.attributes,\n          positions = _this$attributes.positions,\n          vertexValid = _this$attributes.vertexValid,\n          positionSize = this.positionSize;\n      var i = vertexStart;\n      var polygonPositions = polygon.positions,\n          holeIndices = polygon.holeIndices;\n\n      for (var j = 0; j < geometrySize; j++) {\n        var x = polygonPositions[j * positionSize];\n        var y = polygonPositions[j * positionSize + 1];\n        var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n        vertexValid[i] = 1;\n        i++;\n      }\n\n      if (holeIndices) {\n        for (var _j = 0; _j < holeIndices.length; _j++) {\n          vertexValid[vertexStart + holeIndices[_j] / positionSize - 1] = 0;\n        }\n      }\n\n      vertexValid[vertexStart + geometrySize - 1] = 0;\n    }\n  }]);\n\n  return PolygonTesselator;\n}(Tesselator);\n\nexport { PolygonTesselator as default };","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { PhongMaterial } from '@luma.gl/core';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport * as Polygon from '../solid-polygon-layer/polygon';\nimport { replaceInRange } from '../utils';\nvar defaultLineColor = [0, 0, 0, 255];\nvar defaultFillColor = [0, 0, 0, 255];\nvar defaultMaterial = new PhongMaterial();\nvar defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  elevationScale: 1,\n  wireframe: false,\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  lineDashJustified: false,\n  getPolygon: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.polygon;\n    }\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: defaultFillColor\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: defaultLineColor\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getLineDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: defaultMaterial\n};\n\nvar PolygonLayer = function (_CompositeLayer) {\n  _inherits(PolygonLayer, _CompositeLayer);\n\n  function PolygonLayer() {\n    _classCallCheck(this, PolygonLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonLayer).apply(this, arguments));\n  }\n\n  _createClass(PolygonLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        paths: []\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var _this = this;\n\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n      var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n      if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {\n        var paths = this.state.paths.slice();\n        var pathsDiff = changeFlags.dataChanged.map(function (dataRange) {\n          return replaceInRange({\n            data: paths,\n            getIndex: function getIndex(p) {\n              return p.__source.index;\n            },\n            dataRange: dataRange,\n            replace: _this._getPaths(dataRange)\n          });\n        });\n        this.setState({\n          paths: paths,\n          pathsDiff: pathsDiff\n        });\n      } else if (geometryChanged) {\n        this.setState({\n          paths: this._getPaths(),\n          pathsDiff: null\n        });\n      }\n    }\n  }, {\n    key: \"_getPaths\",\n    value: function _getPaths() {\n      var dataRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$props = this.props,\n          data = _this$props.data,\n          getPolygon = _this$props.getPolygon,\n          positionFormat = _this$props.positionFormat;\n      var paths = [];\n      var positionSize = positionFormat === 'XY' ? 2 : 3;\n      var startRow = dataRange.startRow,\n          endRow = dataRange.endRow;\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          objectInfo.index++;\n\n          var _Polygon$normalize = Polygon.normalize(getPolygon(object, objectInfo), positionSize),\n              positions = _Polygon$normalize.positions,\n              holeIndices = _Polygon$normalize.holeIndices;\n\n          if (holeIndices) {\n            for (var i = 0; i <= holeIndices.length; i++) {\n              var path = positions.subarray(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);\n              paths.push(this.getSubLayerRow({\n                path: path\n              }, object, objectInfo.index));\n            }\n          } else {\n            paths.push(this.getSubLayerRow({\n              path: positions\n            }, object, objectInfo.index));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return paths;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          _dataDiff = _this$props2._dataDiff,\n          stroked = _this$props2.stroked,\n          filled = _this$props2.filled,\n          extruded = _this$props2.extruded,\n          wireframe = _this$props2.wireframe,\n          elevationScale = _this$props2.elevationScale,\n          transitions = _this$props2.transitions,\n          positionFormat = _this$props2.positionFormat;\n      var _this$props3 = this.props,\n          lineWidthUnits = _this$props3.lineWidthUnits,\n          lineWidthScale = _this$props3.lineWidthScale,\n          lineWidthMinPixels = _this$props3.lineWidthMinPixels,\n          lineWidthMaxPixels = _this$props3.lineWidthMaxPixels,\n          lineJointRounded = _this$props3.lineJointRounded,\n          lineMiterLimit = _this$props3.lineMiterLimit,\n          lineDashJustified = _this$props3.lineDashJustified;\n      var _this$props4 = this.props,\n          getFillColor = _this$props4.getFillColor,\n          getLineColor = _this$props4.getLineColor,\n          getLineWidth = _this$props4.getLineWidth,\n          getLineDashArray = _this$props4.getLineDashArray,\n          getElevation = _this$props4.getElevation,\n          getPolygon = _this$props4.getPolygon,\n          updateTriggers = _this$props4.updateTriggers,\n          material = _this$props4.material;\n      var _this$state = this.state,\n          paths = _this$state.paths,\n          pathsDiff = _this$state.pathsDiff;\n      var FillLayer = this.getSubLayerClass('fill', SolidPolygonLayer);\n      var StrokeLayer = this.getSubLayerClass('stroke', PathLayer);\n      var polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({\n        _dataDiff: _dataDiff,\n        extruded: extruded,\n        elevationScale: elevationScale,\n        filled: filled,\n        wireframe: wireframe,\n        getElevation: getElevation,\n        getFillColor: getFillColor,\n        getLineColor: getLineColor,\n        material: material,\n        transitions: transitions\n      }, this.getSubLayerProps({\n        id: 'fill',\n        updateTriggers: {\n          getPolygon: updateTriggers.getPolygon,\n          getElevation: updateTriggers.getElevation,\n          getFillColor: updateTriggers.getFillColor,\n          getLineColor: updateTriggers.getLineColor\n        }\n      }), {\n        data: data,\n        positionFormat: positionFormat,\n        getPolygon: getPolygon\n      });\n      var polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({\n        _dataDiff: pathsDiff && function () {\n          return pathsDiff;\n        },\n        widthUnits: lineWidthUnits,\n        widthScale: lineWidthScale,\n        widthMinPixels: lineWidthMinPixels,\n        widthMaxPixels: lineWidthMaxPixels,\n        rounded: lineJointRounded,\n        miterLimit: lineMiterLimit,\n        dashJustified: lineDashJustified,\n        transitions: transitions && {\n          getWidth: transitions.getLineWidth,\n          getColor: transitions.getLineColor,\n          getPath: transitions.getPolygon\n        },\n        getColor: this.getSubLayerAccessor(getLineColor),\n        getWidth: this.getSubLayerAccessor(getLineWidth),\n        getDashArray: this.getSubLayerAccessor(getLineDashArray)\n      }, this.getSubLayerProps({\n        id: 'stroke',\n        updateTriggers: {\n          getWidth: updateTriggers.getLineWidth,\n          getColor: updateTriggers.getLineColor,\n          getDashArray: updateTriggers.getLineDashArray\n        }\n      }), {\n        data: paths,\n        positionFormat: positionFormat,\n        getPath: function getPath(x) {\n          return x.path;\n        }\n      });\n      return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];\n    }\n  }]);\n\n  return PolygonLayer;\n}(CompositeLayer);\n\nexport { PolygonLayer as default };\nPolygonLayer.layerName = 'PolygonLayer';\nPolygonLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import BaseAttribute from '../lib/base-attribute';\nimport { padArray } from '../utils/array-utils';\nvar DEFAULT_TRANSITION_SETTINGS = {\n  interpolation: {\n    duration: 0,\n    easing: function easing(t) {\n      return t;\n    }\n  },\n  spring: {\n    stiffness: 0.05,\n    damping: 0.5\n  }\n};\nexport function normalizeTransitionSettings(userSettings, layerSettings) {\n  if (!userSettings) {\n    return null;\n  }\n\n  if (Number.isFinite(userSettings)) {\n    userSettings = {\n      duration: userSettings\n    };\n  }\n\n  userSettings.type = userSettings.type || 'interpolation';\n  return Object.assign({}, DEFAULT_TRANSITION_SETTINGS[userSettings.type], layerSettings, userSettings);\n}\nexport function getSourceBufferAttribute(gl, attribute) {\n  var size = attribute.size,\n      value = attribute.value,\n      normalized = attribute.normalized,\n      constant = attribute.constant;\n\n  if (constant) {\n    return new BaseAttribute(gl, {\n      constant: constant,\n      value: value,\n      size: size\n    });\n  }\n\n  var buffer = attribute.getBuffer();\n  return new BaseAttribute(gl, {\n    divisor: 0,\n    constant: constant,\n    buffer: buffer,\n    size: size,\n    normalized: normalized\n  });\n}\nexport function getAttributeTypeFromSize(size) {\n  switch (size) {\n    case 1:\n      return 'float';\n\n    case 2:\n      return 'vec2';\n\n    case 3:\n      return 'vec3';\n\n    case 4:\n      return 'vec4';\n\n    default:\n      throw new Error(\"No defined attribute type for size \\\"\".concat(size, \"\\\"\"));\n  }\n}\nexport function cycleBuffers(buffers) {\n  buffers.push(buffers.shift());\n}\nexport function getAttributeBufferLength(attribute, numInstances) {\n  var doublePrecision = attribute.doublePrecision,\n      userData = attribute.userData,\n      value = attribute.value,\n      size = attribute.size;\n  var multiplier = doublePrecision ? 2 : 1;\n  return (userData.noAlloc ? value.length : numInstances * size) * multiplier;\n}\nexport function padBuffer(_ref) {\n  var buffer = _ref.buffer,\n      numInstances = _ref.numInstances,\n      attribute = _ref.attribute,\n      fromLength = _ref.fromLength,\n      fromBufferLayout = _ref.fromBufferLayout,\n      _ref$getData = _ref.getData,\n      getData = _ref$getData === void 0 ? function (x) {\n    return x;\n  } : _ref$getData;\n  var precisionMultiplier = attribute.doublePrecision ? 2 : 1;\n  var size = attribute.size * precisionMultiplier;\n  var offset = attribute.elementOffset * precisionMultiplier;\n  var toBufferLayout = attribute.bufferLayout;\n  var hasBufferLayout = fromBufferLayout && toBufferLayout;\n  var toLength = getAttributeBufferLength(attribute, numInstances);\n\n  if (!hasBufferLayout && fromLength >= toLength) {\n    return;\n  }\n\n  var toData = attribute.constant ? attribute.getValue() : attribute.getBuffer().getData({});\n\n  if (attribute.normalized) {\n    var getter = getData;\n\n    getData = function getData(value, chunk) {\n      return attribute._normalizeConstant(getter(value, chunk));\n    };\n  }\n\n  var getMissingData = attribute.constant ? function (i, chunk) {\n    return getData(toData, chunk);\n  } : function (i, chunk) {\n    return getData(toData.subarray(i, i + size), chunk);\n  };\n  var source = buffer.getData({\n    length: fromLength\n  });\n  var data = new Float32Array(toLength);\n  padArray({\n    source: source,\n    target: data,\n    sourceLayout: fromBufferLayout,\n    targetLayout: toBufferLayout,\n    offset: offset,\n    size: size,\n    getData: getMissingData\n  });\n  buffer.setData({\n    data: data\n  });\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { experimental } from '@deck.gl/core';\nvar Tesselator = experimental.Tesselator;\nvar START_CAP = 1;\nvar END_CAP = 2;\nvar INVALID = 4;\n\nvar PathTesselator = function (_Tesselator) {\n  _inherits(PathTesselator, _Tesselator);\n\n  function PathTesselator(_ref) {\n    var data = _ref.data,\n        getGeometry = _ref.getGeometry,\n        positionFormat = _ref.positionFormat,\n        fp64 = _ref.fp64;\n\n    _classCallCheck(this, PathTesselator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathTesselator).call(this, {\n      data: data,\n      getGeometry: getGeometry,\n      positionFormat: positionFormat,\n      attributes: {\n        startPositions: {\n          size: 3,\n          padding: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        endPositions: {\n          size: 3,\n          padding: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        },\n        startPositions64XyLow: {\n          size: 2,\n          padding: 2,\n          fp64Only: true\n        },\n        endPositions64XyLow: {\n          size: 2,\n          padding: 2,\n          fp64Only: true\n        }\n      }\n    }));\n  }\n\n  _createClass(PathTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      return this.attributes[attributeName];\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(path) {\n      var numPoints = this.getPathLength(path);\n\n      if (numPoints < 2) {\n        return 0;\n      }\n\n      if (this.isClosed(path)) {\n        return numPoints < 3 ? 0 : numPoints + 1;\n      }\n\n      return numPoints - 1;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(path, context) {\n      var _this$attributes = this.attributes,\n          startPositions = _this$attributes.startPositions,\n          endPositions = _this$attributes.endPositions,\n          segmentTypes = _this$attributes.segmentTypes;\n      var geometrySize = context.geometrySize;\n\n      if (geometrySize === 0) {\n        return;\n      }\n\n      var isPathClosed = this.isClosed(path);\n      var startPoint;\n      var endPoint;\n\n      for (var i = context.vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n        startPoint = endPoint || this.getPointOnPath(path, 0);\n        endPoint = this.getPointOnPath(path, ptIndex + 1);\n        segmentTypes[i] = 0;\n\n        if (ptIndex === 0) {\n          if (isPathClosed) {\n            segmentTypes[i] += INVALID;\n          } else {\n            segmentTypes[i] += START_CAP;\n          }\n        }\n\n        if (ptIndex === geometrySize - 1) {\n          if (isPathClosed) {\n            segmentTypes[i] += INVALID;\n          } else {\n            segmentTypes[i] += END_CAP;\n          }\n        }\n\n        startPositions[i * 3 + 3] = startPoint[0];\n        startPositions[i * 3 + 4] = startPoint[1];\n        startPositions[i * 3 + 5] = startPoint[2] || 0;\n        endPositions[i * 3] = endPoint[0];\n        endPositions[i * 3 + 1] = endPoint[1];\n        endPositions[i * 3 + 2] = endPoint[2] || 0;\n      }\n    }\n  }, {\n    key: \"getPathLength\",\n    value: function getPathLength(path) {\n      if (Number.isFinite(path[0])) {\n        return path.length / this.positionSize;\n      }\n\n      return path.length;\n    }\n  }, {\n    key: \"getPointOnPath\",\n    value: function getPointOnPath(path, index) {\n      if (Number.isFinite(path[0])) {\n        var positionSize = this.positionSize;\n\n        if (index * positionSize >= path.length) {\n          index += 1 - path.length / positionSize;\n        }\n\n        return [path[index * positionSize], path[index * positionSize + 1], positionSize === 3 ? path[index * positionSize + 2] : 0];\n      }\n\n      if (index >= path.length) {\n        index += 1 - path.length;\n      }\n\n      return path[index];\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed(path) {\n      var numPoints = this.getPathLength(path);\n      var firstPoint = this.getPointOnPath(path, 0);\n      var lastPoint = this.getPointOnPath(path, numPoints - 1);\n      return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] && firstPoint[2] === lastPoint[2];\n    }\n  }]);\n\n  return PathTesselator;\n}(Tesselator);\n\nexport { PathTesselator as default };","map":null,"metadata":{},"sourceType":"module"}